initSidebarItems({"fn":[["any","Generates a `Strategy` producing `Arbitrary` values of `A`. Unlike `arbitrary`, it should be used for being explicit on what `A` is. For clarity, this may be a good idea."],["any_with","Generates a `Strategy` producing `Arbitrary` values of `A` with the given configuration arguments passed in `args`. Unlike `arbitrary_with`, it should be used for being explicit on what `A` is. For clarity, this may be a good idea."],["arbitrary","Generates a `Strategy` producing `Arbitrary` values of `A`. Works better with type inference than `any::<A>()`."],["arbitrary_with","Generates a `Strategy` producing `Arbitrary` values of `A` with the given configuration arguments passed in `args`. Works better with type inference than `any_with::<A>(args)`."]],"mod":[["functor","Provides higher order `Arbitrary` traits. This is mainly for use by `proptest_derive`."]],"trait":[["Arbitrary","Arbitrary determines a canonical `Strategy` for the implementing type."]],"type":[["Mapped","A normal map from a strategy of `I` to `O`."],["ParamsFor","`ParamsFor` allows you to mention the type of `Parameters` for the input type `A` without directly using associated types or without resorting to existential types. This way, if implementation of `Arbitrary` changes, your tests should not break."],["SMapped","A static map from a strategy of `I` to `O`."],["StrategyFor","`StrategyFor` allows you to mention the type of `Strategy` for the input type `A` without directly using associated types or without resorting to existential types. This way, if implementation of `Arbitrary` changes, your tests should not break. This can be especially beneficial when the type of `Strategy` that you are dealing with is very long in name (the case with generics)."]]});